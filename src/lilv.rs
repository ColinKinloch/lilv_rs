/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __llvm__: ::std::os::raw::c_uint = 1;
pub const __clang__: ::std::os::raw::c_uint = 1;
pub const __clang_major__: ::std::os::raw::c_uint = 8;
pub const __clang_minor__: ::std::os::raw::c_uint = 1;
pub const __clang_patchlevel__: ::std::os::raw::c_uint = 0;
pub const __clang_version__: &'static [u8; 23usize] =
    b"8.1.0 (clang-802.0.42)\x00";
pub const __GNUC_MINOR__: ::std::os::raw::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: ::std::os::raw::c_uint = 1;
pub const __GNUC__: ::std::os::raw::c_uint = 4;
pub const __GXX_ABI_VERSION: ::std::os::raw::c_uint = 1002;
pub const __ATOMIC_RELAXED: ::std::os::raw::c_uint = 0;
pub const __ATOMIC_CONSUME: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_ACQUIRE: ::std::os::raw::c_uint = 2;
pub const __ATOMIC_RELEASE: ::std::os::raw::c_uint = 3;
pub const __ATOMIC_ACQ_REL: ::std::os::raw::c_uint = 4;
pub const __ATOMIC_SEQ_CST: ::std::os::raw::c_uint = 5;
pub const __PRAGMA_REDEFINE_EXTNAME: ::std::os::raw::c_uint = 1;
pub const __VERSION__: &'static [u8; 51usize] =
    b"4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)\x00";
pub const __OBJC_BOOL_IS_BOOL: ::std::os::raw::c_uint = 0;
pub const __CONSTANT_CFSTRINGS__: ::std::os::raw::c_uint = 1;
pub const __BLOCKS__: ::std::os::raw::c_uint = 1;
pub const __ORDER_LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1234;
pub const __ORDER_BIG_ENDIAN__: ::std::os::raw::c_uint = 4321;
pub const __ORDER_PDP_ENDIAN__: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER__: ::std::os::raw::c_uint = 1234;
pub const __LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1;
pub const _LP64: ::std::os::raw::c_uint = 1;
pub const __LP64__: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT__: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX__: ::std::os::raw::c_uint = 127;
pub const __SHRT_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __LONG_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_LONG_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __WCHAR_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INTMAX_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTMAX_MAX__: ::std::os::raw::c_int = -1;
pub const __PTRDIFF_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTPTR_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __UINTPTR_MAX__: ::std::os::raw::c_int = -1;
pub const __SIZEOF_DOUBLE__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_FLOAT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_LONG_DOUBLE__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_POINTER__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SHORT__: ::std::os::raw::c_uint = 2;
pub const __SIZEOF_PTRDIFF_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SIZE_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_WINT_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT128__: ::std::os::raw::c_uint = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __WCHAR_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __WINT_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __FLT_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __FLT_DIG__: ::std::os::raw::c_uint = 6;
pub const __FLT_DECIMAL_DIG__: ::std::os::raw::c_uint = 9;
pub const __FLT_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __FLT_MANT_DIG__: ::std::os::raw::c_uint = 24;
pub const __FLT_MAX_10_EXP__: ::std::os::raw::c_uint = 38;
pub const __FLT_MAX_EXP__: ::std::os::raw::c_uint = 128;
pub const __FLT_MIN_10_EXP__: ::std::os::raw::c_int = -37;
pub const __FLT_MIN_EXP__: ::std::os::raw::c_int = -125;
pub const __DBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __DBL_DIG__: ::std::os::raw::c_uint = 15;
pub const __DBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 17;
pub const __DBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __DBL_MANT_DIG__: ::std::os::raw::c_uint = 53;
pub const __DBL_MAX_10_EXP__: ::std::os::raw::c_uint = 308;
pub const __DBL_MAX_EXP__: ::std::os::raw::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: ::std::os::raw::c_int = -307;
pub const __DBL_MIN_EXP__: ::std::os::raw::c_int = -1021;
pub const __LDBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __LDBL_DIG__: ::std::os::raw::c_uint = 18;
pub const __LDBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __LDBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __LDBL_MANT_DIG__: ::std::os::raw::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: ::std::os::raw::c_uint = 4932;
pub const __LDBL_MAX_EXP__: ::std::os::raw::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: ::std::os::raw::c_int = -4931;
pub const __LDBL_MIN_EXP__: ::std::os::raw::c_int = -16381;
pub const __POINTER_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __BIGGEST_ALIGNMENT__: ::std::os::raw::c_uint = 16;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT64_FMTd__: &'static [u8; 4usize] = b"lld\x00";
pub const __INT64_FMTi__: &'static [u8; 4usize] = b"lli\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_MAX__: ::std::os::raw::c_uint = 255;
pub const __INT8_MAX__: ::std::os::raw::c_uint = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __INT16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __INT32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 4usize] = b"llo\x00";
pub const __UINT64_FMTu__: &'static [u8; 4usize] = b"llu\x00";
pub const __UINT64_FMTx__: &'static [u8; 4usize] = b"llx\x00";
pub const __UINT64_FMTX__: &'static [u8; 4usize] = b"llX\x00";
pub const __UINT64_MAX__: ::std::os::raw::c_int = -1;
pub const __INT64_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_LEAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_LEAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_LEAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_LEAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_LEAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_LEAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_LEAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INT_FAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_FAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_FAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_FAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_FAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_FAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_FAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_FAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __FINITE_MATH_ONLY__: ::std::os::raw::c_uint = 0;
pub const __GNUC_STDC_INLINE__: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __NO_INLINE__: ::std::os::raw::c_uint = 1;
pub const __PIC__: ::std::os::raw::c_uint = 2;
pub const __pic__: ::std::os::raw::c_uint = 2;
pub const __FLT_EVAL_METHOD__: ::std::os::raw::c_uint = 0;
pub const __FLT_RADIX__: ::std::os::raw::c_uint = 2;
pub const __DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __SSP__: ::std::os::raw::c_uint = 1;
pub const __amd64__: ::std::os::raw::c_uint = 1;
pub const __amd64: ::std::os::raw::c_uint = 1;
pub const __x86_64: ::std::os::raw::c_uint = 1;
pub const __x86_64__: ::std::os::raw::c_uint = 1;
pub const __core2: ::std::os::raw::c_uint = 1;
pub const __core2__: ::std::os::raw::c_uint = 1;
pub const __tune_core2__: ::std::os::raw::c_uint = 1;
pub const __NO_MATH_INLINES: ::std::os::raw::c_uint = 1;
pub const __FXSR__: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16: ::std::os::raw::c_uint = 1;
pub const __SSSE3__: ::std::os::raw::c_uint = 1;
pub const __SSE3__: ::std::os::raw::c_uint = 1;
pub const __SSE2__: ::std::os::raw::c_uint = 1;
pub const __SSE2_MATH__: ::std::os::raw::c_uint = 1;
pub const __SSE__: ::std::os::raw::c_uint = 1;
pub const __SSE_MATH__: ::std::os::raw::c_uint = 1;
pub const __MMX__: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: ::std::os::raw::c_uint = 1;
pub const __APPLE_CC__: ::std::os::raw::c_uint = 6000;
pub const __APPLE__: ::std::os::raw::c_uint = 1;
pub const OBJC_NEW_PROPERTIES: ::std::os::raw::c_uint = 1;
pub const __apple_build_version__: ::std::os::raw::c_uint = 8020042;
pub const __DYNAMIC__: ::std::os::raw::c_uint = 1;
pub const __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__:
          ::std::os::raw::c_uint =
    1090;
pub const __MACH__: ::std::os::raw::c_uint = 1;
pub const __STDC__: ::std::os::raw::c_uint = 1;
pub const __STDC_HOSTED__: ::std::os::raw::c_uint = 1;
pub const __STDC_VERSION__: ::std::os::raw::c_uint = 201112;
pub const __STDC_UTF_16__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_32__: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __MAC_OS_X_VERSION_MIN_REQUIRED: ::std::os::raw::c_uint = 1090;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101204;
pub const __DARWIN_WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const LV2_CORE_URI: &'static [u8; 29usize] =
    b"http://lv2plug.in/ns/lv2core\x00";
pub const LV2_CORE_PREFIX: &'static [u8; 30usize] =
    b"http://lv2plug.in/ns/lv2core#\x00";
pub const LV2_CORE__AllpassPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#AllpassPlugin\x00";
pub const LV2_CORE__AmplifierPlugin: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#AmplifierPlugin\x00";
pub const LV2_CORE__AnalyserPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#AnalyserPlugin\x00";
pub const LV2_CORE__AudioPort: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#AudioPort\x00";
pub const LV2_CORE__BandpassPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#BandpassPlugin\x00";
pub const LV2_CORE__CVPort: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#CVPort\x00";
pub const LV2_CORE__ChorusPlugin: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#ChorusPlugin\x00";
pub const LV2_CORE__CombPlugin: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#CombPlugin\x00";
pub const LV2_CORE__CompressorPlugin: &'static [u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#CompressorPlugin\x00";
pub const LV2_CORE__ConstantPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ConstantPlugin\x00";
pub const LV2_CORE__ControlPort: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#ControlPort\x00";
pub const LV2_CORE__ConverterPlugin: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ConverterPlugin\x00";
pub const LV2_CORE__DelayPlugin: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#DelayPlugin\x00";
pub const LV2_CORE__DistortionPlugin: &'static [u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#DistortionPlugin\x00";
pub const LV2_CORE__DynamicsPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#DynamicsPlugin\x00";
pub const LV2_CORE__EQPlugin: &'static [u8; 38usize] =
    b"http://lv2plug.in/ns/lv2core#EQPlugin\x00";
pub const LV2_CORE__EnvelopePlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#EnvelopePlugin\x00";
pub const LV2_CORE__ExpanderPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#ExpanderPlugin\x00";
pub const LV2_CORE__ExtensionData: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#ExtensionData\x00";
pub const LV2_CORE__Feature: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#Feature\x00";
pub const LV2_CORE__FilterPlugin: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#FilterPlugin\x00";
pub const LV2_CORE__FlangerPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#FlangerPlugin\x00";
pub const LV2_CORE__FunctionPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#FunctionPlugin\x00";
pub const LV2_CORE__GatePlugin: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#GatePlugin\x00";
pub const LV2_CORE__GeneratorPlugin: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#GeneratorPlugin\x00";
pub const LV2_CORE__HighpassPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#HighpassPlugin\x00";
pub const LV2_CORE__InputPort: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#InputPort\x00";
pub const LV2_CORE__InstrumentPlugin: &'static [u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#InstrumentPlugin\x00";
pub const LV2_CORE__LimiterPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#LimiterPlugin\x00";
pub const LV2_CORE__LowpassPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#LowpassPlugin\x00";
pub const LV2_CORE__MixerPlugin: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#MixerPlugin\x00";
pub const LV2_CORE__ModulatorPlugin: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#ModulatorPlugin\x00";
pub const LV2_CORE__MultiEQPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#MultiEQPlugin\x00";
pub const LV2_CORE__OscillatorPlugin: &'static [u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#OscillatorPlugin\x00";
pub const LV2_CORE__OutputPort: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#OutputPort\x00";
pub const LV2_CORE__ParaEQPlugin: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#ParaEQPlugin\x00";
pub const LV2_CORE__PhaserPlugin: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#PhaserPlugin\x00";
pub const LV2_CORE__PitchPlugin: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#PitchPlugin\x00";
pub const LV2_CORE__Plugin: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#Plugin\x00";
pub const LV2_CORE__PluginBase: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#PluginBase\x00";
pub const LV2_CORE__Point: &'static [u8; 35usize] =
    b"http://lv2plug.in/ns/lv2core#Point\x00";
pub const LV2_CORE__Port: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/lv2core#Port\x00";
pub const LV2_CORE__PortProperty: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#PortProperty\x00";
pub const LV2_CORE__Resource: &'static [u8; 38usize] =
    b"http://lv2plug.in/ns/lv2core#Resource\x00";
pub const LV2_CORE__ReverbPlugin: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#ReverbPlugin\x00";
pub const LV2_CORE__ScalePoint: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#ScalePoint\x00";
pub const LV2_CORE__SimulatorPlugin: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#SimulatorPlugin\x00";
pub const LV2_CORE__SpatialPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#SpatialPlugin\x00";
pub const LV2_CORE__Specification: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#Specification\x00";
pub const LV2_CORE__SpectralPlugin: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#SpectralPlugin\x00";
pub const LV2_CORE__UtilityPlugin: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#UtilityPlugin\x00";
pub const LV2_CORE__WaveshaperPlugin: &'static [u8; 46usize] =
    b"http://lv2plug.in/ns/lv2core#WaveshaperPlugin\x00";
pub const LV2_CORE__appliesTo: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#appliesTo\x00";
pub const LV2_CORE__binary: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#binary\x00";
pub const LV2_CORE__connectionOptional: &'static [u8; 48usize] =
    b"http://lv2plug.in/ns/lv2core#connectionOptional\x00";
pub const LV2_CORE__control: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#control\x00";
pub const LV2_CORE__default: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#default\x00";
pub const LV2_CORE__designation: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#designation\x00";
pub const LV2_CORE__documentation: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#documentation\x00";
pub const LV2_CORE__enumeration: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#enumeration\x00";
pub const LV2_CORE__extensionData: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#extensionData\x00";
pub const LV2_CORE__freeWheeling: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#freeWheeling\x00";
pub const LV2_CORE__hardRTCapable: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#hardRTCapable\x00";
pub const LV2_CORE__inPlaceBroken: &'static [u8; 43usize] =
    b"http://lv2plug.in/ns/lv2core#inPlaceBroken\x00";
pub const LV2_CORE__index: &'static [u8; 35usize] =
    b"http://lv2plug.in/ns/lv2core#index\x00";
pub const LV2_CORE__integer: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#integer\x00";
pub const LV2_CORE__isLive: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#isLive\x00";
pub const LV2_CORE__latency: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#latency\x00";
pub const LV2_CORE__maximum: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#maximum\x00";
pub const LV2_CORE__microVersion: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#microVersion\x00";
pub const LV2_CORE__minimum: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#minimum\x00";
pub const LV2_CORE__minorVersion: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#minorVersion\x00";
pub const LV2_CORE__name: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/lv2core#name\x00";
pub const LV2_CORE__optionalFeature: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#optionalFeature\x00";
pub const LV2_CORE__port: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/lv2core#port\x00";
pub const LV2_CORE__portProperty: &'static [u8; 42usize] =
    b"http://lv2plug.in/ns/lv2core#portProperty\x00";
pub const LV2_CORE__project: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#project\x00";
pub const LV2_CORE__prototype: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#prototype\x00";
pub const LV2_CORE__reportsLatency: &'static [u8; 44usize] =
    b"http://lv2plug.in/ns/lv2core#reportsLatency\x00";
pub const LV2_CORE__requiredFeature: &'static [u8; 45usize] =
    b"http://lv2plug.in/ns/lv2core#requiredFeature\x00";
pub const LV2_CORE__sampleRate: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#sampleRate\x00";
pub const LV2_CORE__scalePoint: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#scalePoint\x00";
pub const LV2_CORE__symbol: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#symbol\x00";
pub const LV2_CORE__toggled: &'static [u8; 37usize] =
    b"http://lv2plug.in/ns/lv2core#toggled\x00";
pub const LV2_URID_URI: &'static [u8; 30usize] =
    b"http://lv2plug.in/ns/ext/urid\x00";
pub const LV2_URID_PREFIX: &'static [u8; 31usize] =
    b"http://lv2plug.in/ns/ext/urid#\x00";
pub const LV2_URID__map: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/ext/urid#map\x00";
pub const LV2_URID__unmap: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/ext/urid#unmap\x00";
pub const LV2_URID_MAP_URI: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/ext/urid#map\x00";
pub const LV2_URID_UNMAP_URI: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/ext/urid#unmap\x00";
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const LILV_NS_DOAP: &'static [u8; 30usize] =
    b"http://usefulinc.com/ns/doap#\x00";
pub const LILV_NS_FOAF: &'static [u8; 27usize] =
    b"http://xmlns.com/foaf/0.1/\x00";
pub const LILV_NS_LILV: &'static [u8; 29usize] =
    b"http://drobilla.net/ns/lilv#\x00";
pub const LILV_NS_LV2: &'static [u8; 30usize] =
    b"http://lv2plug.in/ns/lv2core#\x00";
pub const LILV_NS_OWL: &'static [u8; 31usize] =
    b"http://www.w3.org/2002/07/owl#\x00";
pub const LILV_NS_RDF: &'static [u8; 44usize] =
    b"http://www.w3.org/1999/02/22-rdf-syntax-ns#\x00";
pub const LILV_NS_RDFS: &'static [u8; 38usize] =
    b"http://www.w3.org/2000/01/rdf-schema#\x00";
pub const LILV_NS_XSD: &'static [u8; 34usize] =
    b"http://www.w3.org/2001/XMLSchema#\x00";
pub const LILV_URI_ATOM_PORT: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/ext/atom#AtomPort\x00";
pub const LILV_URI_AUDIO_PORT: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#AudioPort\x00";
pub const LILV_URI_CONTROL_PORT: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/lv2core#ControlPort\x00";
pub const LILV_URI_CV_PORT: &'static [u8; 36usize] =
    b"http://lv2plug.in/ns/lv2core#CVPort\x00";
pub const LILV_URI_EVENT_PORT: &'static [u8; 41usize] =
    b"http://lv2plug.in/ns/ext/event#EventPort\x00";
pub const LILV_URI_INPUT_PORT: &'static [u8; 39usize] =
    b"http://lv2plug.in/ns/lv2core#InputPort\x00";
pub const LILV_URI_MIDI_EVENT: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/ext/midi#MidiEvent\x00";
pub const LILV_URI_OUTPUT_PORT: &'static [u8; 40usize] =
    b"http://lv2plug.in/ns/lv2core#OutputPort\x00";
pub const LILV_URI_PORT: &'static [u8; 34usize] =
    b"http://lv2plug.in/ns/lv2core#Port\x00";
pub const LILV_OPTION_FILTER_LANG: &'static [u8; 40usize] =
    b"http://drobilla.net/ns/lilv#filter-lang\x00";
pub const LILV_OPTION_DYN_MANIFEST: &'static [u8; 41usize] =
    b"http://drobilla.net/ns/lilv#dyn-manifest\x00";
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
pub type LV2_Handle = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LV2_Feature {
    pub URI: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__LV2_Feature() {
    assert_eq!(::std::mem::size_of::<_LV2_Feature>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _LV2_Feature ) ));
    assert_eq! (::std::mem::align_of::<_LV2_Feature>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _LV2_Feature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Feature ) ) . URI as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Feature ) , "::" ,
                stringify ! ( URI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Feature ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Feature ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for _LV2_Feature {
    fn clone(&self) -> Self { *self }
}
pub type LV2_Feature = _LV2_Feature;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LV2_Descriptor {
    pub URI: *const ::std::os::raw::c_char,
    pub instantiate: ::std::option::Option<unsafe extern "C" fn(descriptor:
                                                                    *const _LV2_Descriptor,
                                                                sample_rate:
                                                                    f64,
                                                                bundle_path:
                                                                    *const ::std::os::raw::c_char,
                                                                features:
                                                                    *const *const LV2_Feature)
                                               -> LV2_Handle>,
    pub connect_port: ::std::option::Option<unsafe extern "C" fn(instance:
                                                                     LV2_Handle,
                                                                 port: u32,
                                                                 data_location:
                                                                     *mut ::std::os::raw::c_void)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(instance:
                                                                 LV2_Handle)>,
    pub run: ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle,
                                                        sample_count: u32)>,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(instance:
                                                                   LV2_Handle)>,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(instance:
                                                                LV2_Handle)>,
    pub extension_data: ::std::option::Option<unsafe extern "C" fn(uri:
                                                                       *const ::std::os::raw::c_char)
                                                  ->
                                                      *const ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout__LV2_Descriptor() {
    assert_eq!(::std::mem::size_of::<_LV2_Descriptor>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _LV2_Descriptor ) ));
    assert_eq! (::std::mem::align_of::<_LV2_Descriptor>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _LV2_Descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . URI as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( URI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . instantiate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( instantiate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . connect_port as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( connect_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . activate as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . run as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( run ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . deactivate as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( deactivate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . cleanup as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_Descriptor ) ) . extension_data as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_Descriptor ) ,
                "::" , stringify ! ( extension_data ) ));
}
impl Clone for _LV2_Descriptor {
    fn clone(&self) -> Self { *self }
}
pub type LV2_Descriptor = _LV2_Descriptor;
extern "C" {
    pub fn lv2_descriptor(index: u32) -> *const LV2_Descriptor;
}
pub type LV2_Descriptor_Function =
    ::std::option::Option<unsafe extern "C" fn(index: u32)
                              -> *const LV2_Descriptor>;
pub type LV2_Lib_Handle = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LV2_Lib_Descriptor {
    pub handle: LV2_Lib_Handle,
    pub size: u32,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(handle:
                                                                LV2_Lib_Handle)>,
    pub get_plugin: ::std::option::Option<unsafe extern "C" fn(handle:
                                                                   LV2_Lib_Handle,
                                                               index: u32)
                                              -> *const LV2_Descriptor>,
}
#[test]
fn bindgen_test_layout_LV2_Lib_Descriptor() {
    assert_eq!(::std::mem::size_of::<LV2_Lib_Descriptor>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( LV2_Lib_Descriptor ) ));
    assert_eq! (::std::mem::align_of::<LV2_Lib_Descriptor>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( LV2_Lib_Descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LV2_Lib_Descriptor ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LV2_Lib_Descriptor ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LV2_Lib_Descriptor ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LV2_Lib_Descriptor ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LV2_Lib_Descriptor ) ) . cleanup as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LV2_Lib_Descriptor ) ,
                "::" , stringify ! ( cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LV2_Lib_Descriptor ) ) . get_plugin as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( LV2_Lib_Descriptor ) ,
                "::" , stringify ! ( get_plugin ) ));
}
impl Clone for LV2_Lib_Descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lv2_lib_descriptor(bundle_path: *const ::std::os::raw::c_char,
                              features: *const *const LV2_Feature)
     -> *const LV2_Lib_Descriptor;
}
pub type LV2_Lib_Descriptor_Function =
    ::std::option::Option<unsafe extern "C" fn(bundle_path:
                                                   *const ::std::os::raw::c_char,
                                               features:
                                                   *const *const LV2_Feature)
                              -> *const LV2_Lib_Descriptor>;
pub type LV2_URID_Map_Handle = *mut ::std::os::raw::c_void;
pub type LV2_URID_Unmap_Handle = *mut ::std::os::raw::c_void;
pub type LV2_URID = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LV2_URID_Map {
    pub handle: LV2_URID_Map_Handle,
    pub map: ::std::option::Option<unsafe extern "C" fn(handle:
                                                            LV2_URID_Map_Handle,
                                                        uri:
                                                            *const ::std::os::raw::c_char)
                                       -> LV2_URID>,
}
#[test]
fn bindgen_test_layout__LV2_URID_Map() {
    assert_eq!(::std::mem::size_of::<_LV2_URID_Map>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _LV2_URID_Map ) ));
    assert_eq! (::std::mem::align_of::<_LV2_URID_Map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _LV2_URID_Map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_URID_Map ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_URID_Map ) , "::"
                , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_URID_Map ) ) . map as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_URID_Map ) , "::"
                , stringify ! ( map ) ));
}
impl Clone for _LV2_URID_Map {
    fn clone(&self) -> Self { *self }
}
pub type LV2_URID_Map = _LV2_URID_Map;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LV2_URID_Unmap {
    pub handle: LV2_URID_Unmap_Handle,
    pub unmap: ::std::option::Option<unsafe extern "C" fn(handle:
                                                              LV2_URID_Unmap_Handle,
                                                          urid: LV2_URID)
                                         -> *const ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout__LV2_URID_Unmap() {
    assert_eq!(::std::mem::size_of::<_LV2_URID_Unmap>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _LV2_URID_Unmap ) ));
    assert_eq! (::std::mem::align_of::<_LV2_URID_Unmap>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _LV2_URID_Unmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_URID_Unmap ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_URID_Unmap ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LV2_URID_Unmap ) ) . unmap as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _LV2_URID_Unmap ) ,
                "::" , stringify ! ( unmap ) ));
}
impl Clone for _LV2_URID_Unmap {
    fn clone(&self) -> Self { *self }
}
pub type LV2_URID_Unmap = _LV2_URID_Unmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvPluginImpl {
    _unused: [u8; 0],
}
pub type LilvPlugin = LilvPluginImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvPluginClassImpl {
    _unused: [u8; 0],
}
pub type LilvPluginClass = LilvPluginClassImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvPortImpl {
    _unused: [u8; 0],
}
pub type LilvPort = LilvPortImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvScalePointImpl {
    _unused: [u8; 0],
}
pub type LilvScalePoint = LilvScalePointImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvUIImpl {
    _unused: [u8; 0],
}
pub type LilvUI = LilvUIImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvNodeImpl {
    _unused: [u8; 0],
}
pub type LilvNode = LilvNodeImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvWorldImpl {
    _unused: [u8; 0],
}
pub type LilvWorld = LilvWorldImpl;
/**
   @cond LILV_DOCUMENT_INSTANCE_IMPL
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LilvInstanceImpl {
    pub lv2_descriptor: *const LV2_Descriptor,
    pub lv2_handle: LV2_Handle,
    pub pimpl: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_LilvInstanceImpl() {
    assert_eq!(::std::mem::size_of::<LilvInstanceImpl>() , 24usize , concat !
               ( "Size of: " , stringify ! ( LilvInstanceImpl ) ));
    assert_eq! (::std::mem::align_of::<LilvInstanceImpl>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( LilvInstanceImpl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LilvInstanceImpl ) ) . lv2_descriptor as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( LilvInstanceImpl ) ,
                "::" , stringify ! ( lv2_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LilvInstanceImpl ) ) . lv2_handle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( LilvInstanceImpl ) ,
                "::" , stringify ! ( lv2_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const LilvInstanceImpl ) ) . pimpl as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( LilvInstanceImpl ) ,
                "::" , stringify ! ( pimpl ) ));
}
impl Clone for LilvInstanceImpl {
    fn clone(&self) -> Self { *self }
}
pub type LilvInstance = LilvInstanceImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LilvStateImpl {
    _unused: [u8; 0],
}
pub type LilvState = LilvStateImpl;
pub type LilvIter = ::std::os::raw::c_void;
pub type LilvPluginClasses = ::std::os::raw::c_void;
pub type LilvPlugins = ::std::os::raw::c_void;
pub type LilvScalePoints = ::std::os::raw::c_void;
pub type LilvUIs = ::std::os::raw::c_void;
pub type LilvNodes = ::std::os::raw::c_void;
extern "C" {
    /**
   Free memory allocated by Lilv.

   This function exists because some systems require memory allocated by a
   library to be freed by code in the same library.  It is otherwise equivalent
   to the standard C free() function.
*/
    pub fn lilv_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
   Convert a file URI string to a local path string.
   For example, "file://foo/bar/baz.ttl" returns "/foo/bar/baz.ttl".
   Return value is shared and must not be deleted by caller.
   This function does not handle escaping correctly and should not be used for
   general file URIs.  Use lilv_file_uri_parse() instead.
   @return `uri` converted to a path, or NULL on failure (URI is not local).
*/
    pub fn lilv_uri_to_path(uri: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
   Convert a file URI string to a local path string.
   For example, "file://foo/bar%20one/baz.ttl" returns "/foo/bar one/baz.ttl".
   Return value must be freed by caller with lilv_free().
   @param uri The file URI to parse.
   @param hostname If non-NULL, set to the hostname in the URI, if any.
   @return `uri` converted to a path, or NULL on failure (URI is not local).
*/
    pub fn lilv_file_uri_parse(uri: *const ::std::os::raw::c_char,
                               hostname: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /**
   Create a new URI value.
   Returned value must be freed by caller with lilv_node_free().
*/
    pub fn lilv_new_uri(world: *mut LilvWorld,
                        uri: *const ::std::os::raw::c_char) -> *mut LilvNode;
}
extern "C" {
    /**
   Create a new file URI value.
   @param world The world.
   @param host Host name, or NULL.
   @param path Path on host.
   @return A new node that must be freed by caller.

   Relative paths are resolved against the current working directory.  Note
   that this may yield unexpected results if `host` is another machine.
*/
    pub fn lilv_new_file_uri(world: *mut LilvWorld,
                             host: *const ::std::os::raw::c_char,
                             path: *const ::std::os::raw::c_char)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Create a new string value (with no language).
   Returned value must be freed by caller with lilv_node_free().
*/
    pub fn lilv_new_string(world: *mut LilvWorld,
                           str: *const ::std::os::raw::c_char)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Create a new integer value.
   Returned value must be freed by caller with lilv_node_free().
*/
    pub fn lilv_new_int(world: *mut LilvWorld, val: ::std::os::raw::c_int)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Create a new floating point value.
   Returned value must be freed by caller with lilv_node_free().
*/
    pub fn lilv_new_float(world: *mut LilvWorld, val: f32) -> *mut LilvNode;
}
extern "C" {
    /**
   Create a new boolean value.
   Returned value must be freed by caller with lilv_node_free().
*/
    pub fn lilv_new_bool(world: *mut LilvWorld, val: bool) -> *mut LilvNode;
}
extern "C" {
    /**
   Free a LilvNode.
   It is safe to call this function on NULL.
*/
    pub fn lilv_node_free(val: *mut LilvNode);
}
extern "C" {
    /**
   Duplicate a LilvNode.
*/
    pub fn lilv_node_duplicate(val: *const LilvNode) -> *mut LilvNode;
}
extern "C" {
    /**
   Return whether two values are equivalent.
*/
    pub fn lilv_node_equals(value: *const LilvNode, other: *const LilvNode)
     -> bool;
}
extern "C" {
    /**
   Return this value as a Turtle/SPARQL token.
   Returned value must be freed by caller with lilv_free().
   <table>
   <caption>Example Turtle Tokens</caption>
   <tr><th>URI</th><td>&lt;http://example.org/foo &gt;</td></tr>
   <tr><th>QName</td><td>doap:name</td></tr>
   <tr><th>String</td><td>"this is a string"</td></tr>
   <tr><th>Float</td><td>1.0</td></tr>
   <tr><th>Integer</td><td>1</td></tr>
   <tr><th>Boolean</td><td>true</td></tr>
   </table>
*/
    pub fn lilv_node_get_turtle_token(value: *const LilvNode)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /**
   Return whether the value is a URI (resource).
*/
    pub fn lilv_node_is_uri(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return this value as a URI string, e.g. "http://example.org/foo".
   Valid to call only if `lilv_node_is_uri(value)` returns true.
   Returned value is owned by `value` and must not be freed by caller.
*/
    pub fn lilv_node_as_uri(value: *const LilvNode)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
   Return whether the value is a blank node (resource with no URI).
*/
    pub fn lilv_node_is_blank(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return this value as a blank node identifier, e.g. "genid03".
   Valid to call only if `lilv_node_is_blank(value)` returns true.
   Returned value is owned by `value` and must not be freed by caller.
*/
    pub fn lilv_node_as_blank(value: *const LilvNode)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
   Return whether this value is a literal (i.e. not a URI).
   Returns true if `value` is a string or numeric value.
*/
    pub fn lilv_node_is_literal(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return whether this value is a string literal.
   Returns true if `value` is a string value (and not numeric).
*/
    pub fn lilv_node_is_string(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return `value` as a string.
*/
    pub fn lilv_node_as_string(value: *const LilvNode)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
   Return the path of a file URI node.
   Returns NULL if `value` is not a file URI.
   Returned value must be freed by caller with lilv_free().
*/
    pub fn lilv_node_get_path(value: *const LilvNode,
                              hostname: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /**
   Return whether this value is a decimal literal.
*/
    pub fn lilv_node_is_float(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return `value` as a float.
   Valid to call only if `lilv_node_is_float(value)` or
   `lilv_node_is_int(value)` returns true.
*/
    pub fn lilv_node_as_float(value: *const LilvNode) -> f32;
}
extern "C" {
    /**
   Return whether this value is an integer literal.
*/
    pub fn lilv_node_is_int(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return `value` as an integer.
   Valid to call only if `lilv_node_is_int(value)` returns true.
*/
    pub fn lilv_node_as_int(value: *const LilvNode) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Return whether this value is a boolean.
*/
    pub fn lilv_node_is_bool(value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return `value` as a bool.
   Valid to call only if `lilv_node_is_bool(value)` returns true.
*/
    pub fn lilv_node_as_bool(value: *const LilvNode) -> bool;
}
extern "C" {
    pub fn lilv_plugin_classes_free(collection: *mut LilvPluginClasses);
}
extern "C" {
    pub fn lilv_plugin_classes_size(collection: *const LilvPluginClasses)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lilv_plugin_classes_begin(collection: *const LilvPluginClasses)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_plugin_classes_get(collection: *const LilvPluginClasses,
                                   i: *mut LilvIter)
     -> *const LilvPluginClass;
}
extern "C" {
    pub fn lilv_plugin_classes_next(collection: *const LilvPluginClasses,
                                    i: *mut LilvIter) -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_plugin_classes_is_end(collection: *const LilvPluginClasses,
                                      i: *mut LilvIter) -> bool;
}
extern "C" {
    /**
   Get a plugin class from `classes` by URI.
   Return value is shared (stored in `classes`) and must not be freed or
   modified by the caller in any way.
   @return NULL if no plugin class with `uri` is found in `classes`.
*/
    pub fn lilv_plugin_classes_get_by_uri(classes: *const LilvPluginClasses,
                                          uri: *const LilvNode)
     -> *const LilvPluginClass;
}
extern "C" {
    pub fn lilv_scale_points_free(collection: *mut LilvScalePoints);
}
extern "C" {
    pub fn lilv_scale_points_size(collection: *const LilvScalePoints)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lilv_scale_points_begin(collection: *const LilvScalePoints)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_scale_points_get(collection: *const LilvScalePoints,
                                 i: *mut LilvIter) -> *const LilvScalePoint;
}
extern "C" {
    pub fn lilv_scale_points_next(collection: *const LilvScalePoints,
                                  i: *mut LilvIter) -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_scale_points_is_end(collection: *const LilvScalePoints,
                                    i: *mut LilvIter) -> bool;
}
extern "C" {
    pub fn lilv_uis_free(collection: *mut LilvUIs);
}
extern "C" {
    pub fn lilv_uis_size(collection: *const LilvUIs)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lilv_uis_begin(collection: *const LilvUIs) -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_uis_get(collection: *const LilvUIs, i: *mut LilvIter)
     -> *const LilvUI;
}
extern "C" {
    pub fn lilv_uis_next(collection: *const LilvUIs, i: *mut LilvIter)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_uis_is_end(collection: *const LilvUIs, i: *mut LilvIter)
     -> bool;
}
extern "C" {
    /**
   Get a UI from `uis` by URI.
   Return value is shared (stored in `uis`) and must not be freed or
   modified by the caller in any way.
   @return NULL if no UI with `uri` is found in `list`.
*/
    pub fn lilv_uis_get_by_uri(uis: *const LilvUIs, uri: *const LilvNode)
     -> *const LilvUI;
}
extern "C" {
    pub fn lilv_nodes_free(collection: *mut LilvNodes);
}
extern "C" {
    pub fn lilv_nodes_size(collection: *const LilvNodes)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lilv_nodes_begin(collection: *const LilvNodes) -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_nodes_get(collection: *const LilvNodes, i: *mut LilvIter)
     -> *const LilvNode;
}
extern "C" {
    pub fn lilv_nodes_next(collection: *const LilvNodes, i: *mut LilvIter)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_nodes_is_end(collection: *const LilvNodes, i: *mut LilvIter)
     -> bool;
}
extern "C" {
    pub fn lilv_nodes_get_first(collection: *const LilvNodes)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Return whether `values` contains `value`.
*/
    pub fn lilv_nodes_contains(values: *const LilvNodes,
                               value: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return a new LilvNodes that contains all nodes from both `a` and `b`.
*/
    pub fn lilv_nodes_merge(a: *const LilvNodes, b: *const LilvNodes)
     -> *mut LilvNodes;
}
extern "C" {
    pub fn lilv_plugins_size(collection: *const LilvPlugins)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn lilv_plugins_begin(collection: *const LilvPlugins)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_plugins_get(collection: *const LilvPlugins, i: *mut LilvIter)
     -> *const LilvPlugin;
}
extern "C" {
    pub fn lilv_plugins_next(collection: *const LilvPlugins, i: *mut LilvIter)
     -> *mut LilvIter;
}
extern "C" {
    pub fn lilv_plugins_is_end(collection: *const LilvPlugins,
                               i: *mut LilvIter) -> bool;
}
extern "C" {
    /**
   Get a plugin from `plugins` by URI.
   Return value is shared (stored in `plugins`) and must not be freed or
   modified by the caller in any way.
   @return NULL if no plugin with `uri` is found in `plugins`.
*/
    pub fn lilv_plugins_get_by_uri(plugins: *const LilvPlugins,
                                   uri: *const LilvNode) -> *const LilvPlugin;
}
extern "C" {
    /**
   Initialize a new, empty world.
   If initialization fails, NULL is returned.
*/
    pub fn lilv_world_new() -> *mut LilvWorld;
}
extern "C" {
    /**
   Set an option option for `world`.

   Currently recognized options:
   @ref LILV_OPTION_FILTER_LANG
   @ref LILV_OPTION_DYN_MANIFEST
*/
    pub fn lilv_world_set_option(world: *mut LilvWorld,
                                 uri: *const ::std::os::raw::c_char,
                                 value: *const LilvNode);
}
extern "C" {
    /**
   Destroy the world, mwahaha.
   It is safe to call this function on NULL.
   Note that destroying `world` will destroy all the objects it contains
   (e.g. instances of LilvPlugin).  Do not destroy the world until you are
   finished with all objects that came from it.
*/
    pub fn lilv_world_free(world: *mut LilvWorld);
}
extern "C" {
    /**
   Load all installed LV2 bundles on the system.
   This is the recommended way for hosts to load LV2 data.  It implements the
   established/standard best practice for discovering all LV2 data on the
   system.  The environment variable LV2_PATH may be used to control where
   this function will look for bundles.

   Hosts should use this function rather than explicitly load bundles, except
   in special circumstances (e.g. development utilities, or hosts that ship
   with special plugin bundles which are installed to a known location).
*/
    pub fn lilv_world_load_all(world: *mut LilvWorld);
}
extern "C" {
    /**
   Load a specific bundle.
   `bundle_uri` must be a fully qualified URI to the bundle directory,
   with the trailing slash, eg. file:///usr/lib/lv2/foo.lv2/

   Normal hosts should not need this function (use lilv_world_load_all()).

   Hosts MUST NOT attach any long-term significance to bundle paths
   (e.g. in save files), since there are no guarantees they will remain
   unchanged between (or even during) program invocations. Plugins (among
   other things) MUST be identified by URIs (not paths) in save files.
*/
    pub fn lilv_world_load_bundle(world: *mut LilvWorld,
                                  bundle_uri: *const LilvNode);
}
extern "C" {
    /**
   Load all specifications from currently loaded bundles.

   This is for hosts that explicitly load specific bundles, its use is not
   necessary when using lilv_world_load_all().  This function parses the
   specifications and adds them to the model.
*/
    pub fn lilv_world_load_specifications(world: *mut LilvWorld);
}
extern "C" {
    /**
   Load all plugin classes from currently loaded specifications.

   Must be called after lilv_world_load_specifications().  This is for hosts
   that explicitly load specific bundles, its use is not necessary when using
   lilv_world_load_all().
*/
    pub fn lilv_world_load_plugin_classes(world: *mut LilvWorld);
}
extern "C" {
    /**
   Unload a specific bundle.

   This unloads statements loaded by lilv_world_load_bundle().  Note that this
   is not necessarily all information loaded from the bundle.  If any resources
   have been separately loaded with lilv_world_load_resource(), they must be
   separately unloaded with lilv_world_unload_resource().
*/
    pub fn lilv_world_unload_bundle(world: *mut LilvWorld,
                                    bundle_uri: *const LilvNode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Load all the data associated with the given `resource`.
   @param world The world.
   @param resource Must be a subject (i.e. a URI or a blank node).
   @return The number of files parsed, or -1 on error

   All accessible data files linked to `resource` with rdfs:seeAlso will be
   loaded into the world model.
*/
    pub fn lilv_world_load_resource(world: *mut LilvWorld,
                                    resource: *const LilvNode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Unload all the data associated with the given `resource`.
   @param world The world.
   @param resource Must be a subject (i.e. a URI or a blank node).

   This unloads all data loaded by a previous call to
   lilv_world_load_resource() with the given `resource`.
*/
    pub fn lilv_world_unload_resource(world: *mut LilvWorld,
                                      resource: *const LilvNode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Get the parent of all other plugin classes, lv2:Plugin.
*/
    pub fn lilv_world_get_plugin_class(world: *const LilvWorld)
     -> *const LilvPluginClass;
}
extern "C" {
    /**
   Return a list of all found plugin classes.
   Returned list is owned by world and must not be freed by the caller.
*/
    pub fn lilv_world_get_plugin_classes(world: *const LilvWorld)
     -> *const LilvPluginClasses;
}
extern "C" {
    /**
   Return a list of all found plugins.
   The returned list contains just enough references to query
   or instantiate plugins.  The data for a particular plugin will not be
   loaded into memory until a call to an lilv_plugin_* function results in
   a query (at which time the data is cached with the LilvPlugin so future
   queries are very fast).

   The returned list and the plugins it contains are owned by `world`
   and must not be freed by caller.
*/
    pub fn lilv_world_get_all_plugins(world: *const LilvWorld)
     -> *const LilvPlugins;
}
extern "C" {
    /**
   Find nodes matching a triple pattern.
   Either `subject` or `object` may be NULL (i.e. a wildcard), but not both.
   @return All matches for the wildcard field, or NULL.
*/
    pub fn lilv_world_find_nodes(world: *mut LilvWorld,
                                 subject: *const LilvNode,
                                 predicate: *const LilvNode,
                                 object: *const LilvNode) -> *mut LilvNodes;
}
extern "C" {
    /**
   Find a single node that matches a pattern.
   Exactly one of `subject`, `predicate`, `object` must be NULL.
   This function is equivalent to
   lilv_nodes_get_first(lilv_world_find_nodes(...)) but simplifies the common
   case of only wanting a single value.
   @return the first matching node, or NULL if no matches are found.
*/
    pub fn lilv_world_get(world: *mut LilvWorld, subject: *const LilvNode,
                          predicate: *const LilvNode, object: *const LilvNode)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Return true iff a statement matching a certain pattern exists.

   This is useful for checking if particular statement exists without having to
   bother with collections and memory management.

   @param world The world.
   @param subject Subject of statement, or NULL for anything.
   @param predicate Predicate (key) of statement, or NULL for anything.
   @param object Object (value) of statement, or NULL for anything.
*/
    pub fn lilv_world_ask(world: *mut LilvWorld, subject: *const LilvNode,
                          predicate: *const LilvNode, object: *const LilvNode)
     -> bool;
}
extern "C" {
    /**
   Get an LV2 symbol for some subject.

   This will return the lv2:symbol property of the subject if it is given
   explicitly, and otherwise will attempt to derive a symbol from the URI.
   @return A string node that is a valid LV2 symbol, or NULL on error.
*/
    pub fn lilv_world_get_symbol(world: *mut LilvWorld,
                                 subject: *const LilvNode) -> *mut LilvNode;
}
extern "C" {
    /**
   Check if `plugin` is valid.
   This is not a rigorous validator, but can be used to reject some malformed
   plugins that could cause bugs (e.g. plugins with missing required fields).

   Note that normal hosts do NOT need to use this - lilv does not
   load invalid plugins into plugin lists.  This is included for plugin
   testing utilities, etc.
   @return true iff `plugin` is valid.
*/
    pub fn lilv_plugin_verify(plugin: *const LilvPlugin) -> bool;
}
extern "C" {
    /**
   Get the URI of `plugin`.
   Any serialization that refers to plugins should refer to them by this.
   Hosts SHOULD NOT save any filesystem paths, plugin indexes, etc. in saved
   files; save only the URI.

   The URI is a globally unique identifier for one specific plugin.  Two
   plugins with the same URI are compatible in port signature, and should
   be guaranteed to work in a compatible and consistent way.  If a plugin
   is upgraded in an incompatible way (eg if it has different ports), it
   MUST have a different URI than it's predecessor.

   @return A shared URI value which must not be modified or freed.
*/
    pub fn lilv_plugin_get_uri(plugin: *const LilvPlugin) -> *const LilvNode;
}
extern "C" {
    /**
   Get the (resolvable) URI of the plugin's "main" bundle.
   This returns the URI of the bundle where the plugin itself was found.  Note
   that the data for a plugin may be spread over many bundles, that is,
   lilv_plugin_get_data_uris() may return URIs which are not within this
   bundle.

   Typical hosts should not need to use this function.
   Note this always returns a fully qualified URI.  If you want a local
   filesystem path, use lilv_file_uri_parse().
   @return a shared string which must not be modified or freed.
*/
    pub fn lilv_plugin_get_bundle_uri(plugin: *const LilvPlugin)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the (resolvable) URIs of the RDF data files that define a plugin.
   Typical hosts should not need to use this function.
   Note this always returns fully qualified URIs.  If you want local
   filesystem paths, use lilv_file_uri_parse().
   @return a list of complete URLs eg. "file:///foo/ABundle.lv2/aplug.ttl",
   which is shared and must not be modified or freed.
*/
    pub fn lilv_plugin_get_data_uris(plugin: *const LilvPlugin)
     -> *const LilvNodes;
}
extern "C" {
    /**
   Get the (resolvable) URI of the shared library for `plugin`.
   Note this always returns a fully qualified URI.  If you want a local
   filesystem path, use lilv_file_uri_parse().
   @return a shared string which must not be modified or freed.
*/
    pub fn lilv_plugin_get_library_uri(plugin: *const LilvPlugin)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the name of `plugin`.
   This returns the name (doap:name) of the plugin.  The name may be
   translated according to the current locale, this value MUST NOT be used
   as a plugin identifier (use the URI for that).
   Returned value must be freed by the caller.
*/
    pub fn lilv_plugin_get_name(plugin: *const LilvPlugin) -> *mut LilvNode;
}
extern "C" {
    /**
   Get the class this plugin belongs to (e.g. Filters).
*/
    pub fn lilv_plugin_get_class(plugin: *const LilvPlugin)
     -> *const LilvPluginClass;
}
extern "C" {
    /**
   Get a value associated with the plugin in a plugin's data files.
   `predicate` must be either a URI or a QName.

   Returns the ?object of all triples found of the form:

   <code>&lt;plugin-uri&gt; predicate ?object</code>

   May return NULL if the property was not found, or if object(s) is not
   sensibly represented as a LilvNodes (e.g. blank nodes).
   Return value must be freed by caller with lilv_nodes_free().
*/
    pub fn lilv_plugin_get_value(p: *const LilvPlugin,
                                 predicate: *const LilvNode)
     -> *mut LilvNodes;
}
extern "C" {
    /**
   Return whether a feature is supported by a plugin.
   This will return true if the feature is an optional or required feature
   of the plugin.
*/
    pub fn lilv_plugin_has_feature(p: *const LilvPlugin,
                                   feature_uri: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Get the LV2 Features supported (required or optionally) by a plugin.
   A feature is "supported" by a plugin if it is required OR optional.

   Since required features have special rules the host must obey, this function
   probably shouldn't be used by normal hosts.  Using lilv_plugin_get_optional_features()
   and lilv_plugin_get_required_features() separately is best in most cases.

   Returned value must be freed by caller with lilv_nodes_free().
*/
    pub fn lilv_plugin_get_supported_features(p: *const LilvPlugin)
     -> *mut LilvNodes;
}
extern "C" {
    /**
   Get the LV2 Features required by a plugin.
   If a feature is required by a plugin, hosts MUST NOT use the plugin if they do not
   understand (or are unable to support) that feature.

   All values returned here MUST be passed to the plugin's instantiate method
   (along with data, if necessary, as defined by the feature specification)
   or plugin instantiation will fail.

   Return value must be freed by caller with lilv_nodes_free().
*/
    pub fn lilv_plugin_get_required_features(p: *const LilvPlugin)
     -> *mut LilvNodes;
}
extern "C" {
    /**
   Get the LV2 Features optionally supported by a plugin.
   Hosts MAY ignore optional plugin features for whatever reasons.  Plugins
   MUST operate (at least somewhat) if they are instantiated without being
   passed optional features.

   Return value must be freed by caller with lilv_nodes_free().
*/
    pub fn lilv_plugin_get_optional_features(p: *const LilvPlugin)
     -> *mut LilvNodes;
}
extern "C" {
    /**
   Return whether or not a plugin provides a specific extension data.
*/
    pub fn lilv_plugin_has_extension_data(p: *const LilvPlugin,
                                          uri: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Get a sequence of all extension data provided by a plugin.
   This can be used to find which URIs lilv_instance_get_extension_data()
   will return a value for without instantiating the plugin.
*/
    pub fn lilv_plugin_get_extension_data(p: *const LilvPlugin)
     -> *mut LilvNodes;
}
extern "C" {
    /**
   Get the number of ports on this plugin.
*/
    pub fn lilv_plugin_get_num_ports(p: *const LilvPlugin) -> u32;
}
extern "C" {
    /**
   Get the port ranges (minimum, maximum and default values) for all ports.
   `min_values`, `max_values` and `def_values` must either point to an array
   of N floats, where N is the value returned by lilv_plugin_get_num_ports()
   for this plugin, or NULL.  The elements of the array will be set to the
   the minimum, maximum and default values of the ports on this plugin,
   with array index corresponding to port index.  If a port doesn't have a
   minimum, maximum or default value, or the port's type is not float, the
   corresponding array element will be set to NAN.

   This is a convenience method for the common case of getting the range of
   all float ports on a plugin, and may be significantly faster than
   repeated calls to lilv_port_get_range().
*/
    pub fn lilv_plugin_get_port_ranges_float(p: *const LilvPlugin,
                                             min_values: *mut f32,
                                             max_values: *mut f32,
                                             def_values: *mut f32);
}
extern "C" {
    /**
   Get the number of ports on this plugin that are members of some class(es).
   Note that this is a varargs function so ports fitting any type 'profile'
   desired can be found quickly.  REMEMBER TO TERMINATE THE PARAMETER LIST
   OF THIS FUNCTION WITH NULL OR VERY NASTY THINGS WILL HAPPEN.
*/
    pub fn lilv_plugin_get_num_ports_of_class(p: *const LilvPlugin,
                                              class_1: *const LilvNode, ...)
     -> u32;
}
extern "C" {
    /**
   Variant of lilv_plugin_get_num_ports_of_class() that takes a va_list.

   This function calls va_arg() on `args` but does not call va_end().
*/
    pub fn lilv_plugin_get_num_ports_of_class_va(p: *const LilvPlugin,
                                                 class_1: *const LilvNode,
                                                 args: *mut __va_list_tag)
     -> u32;
}
extern "C" {
    /**
   Return whether or not the plugin introduces (and reports) latency.
   The index of the latency port can be found with
   lilv_plugin_get_latency_port() ONLY if this function returns true.
*/
    pub fn lilv_plugin_has_latency(p: *const LilvPlugin) -> bool;
}
extern "C" {
    /**
   Return the index of the plugin's latency port.
   It is a fatal error to call this on a plugin without checking if the port
   exists by first calling lilv_plugin_has_latency().

   Any plugin that introduces unwanted latency that should be compensated for
   (by hosts with the ability/need) MUST provide this port, which is a control
   rate output port that reports the latency for each cycle in frames.
*/
    pub fn lilv_plugin_get_latency_port_index(p: *const LilvPlugin) -> u32;
}
extern "C" {
    /**
   Get a port on `plugin` by `index`.
*/
    pub fn lilv_plugin_get_port_by_index(plugin: *const LilvPlugin,
                                         index: u32) -> *const LilvPort;
}
extern "C" {
    /**
   Get a port on `plugin` by `symbol`.
   Note this function is slower than lilv_plugin_get_port_by_index(),
   especially on plugins with a very large number of ports.
*/
    pub fn lilv_plugin_get_port_by_symbol(plugin: *const LilvPlugin,
                                          symbol: *const LilvNode)
     -> *const LilvPort;
}
extern "C" {
    /**
   Get a port on `plugin` by its lv2:designation.

   The designation of a port describes the meaning, assignment, allocation or
   role of the port, e.g. "left channel" or "gain".  If found, the port with
   matching `port_class` and `designation` is be returned, otherwise NULL is
   returned.  The `port_class` can be used to distinguish the input and output
   ports for a particular designation.  If `port_class` is NULL, any port with
   the given designation will be returned.
*/
    pub fn lilv_plugin_get_port_by_designation(plugin: *const LilvPlugin,
                                               port_class: *const LilvNode,
                                               designation: *const LilvNode)
     -> *const LilvPort;
}
extern "C" {
    /**
   Get the project the plugin is a part of.

   More information about the project can be read via lilv_world_find_nodes(),
   typically using properties from DOAP (e.g. doap:name).
*/
    pub fn lilv_plugin_get_project(plugin: *const LilvPlugin)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Get the full name of the plugin's author.
   Returns NULL if author name is not present.
   Returned value must be freed by caller.
*/
    pub fn lilv_plugin_get_author_name(plugin: *const LilvPlugin)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Get the email address of the plugin's author.
   Returns NULL if author email address is not present.
   Returned value must be freed by caller.
*/
    pub fn lilv_plugin_get_author_email(plugin: *const LilvPlugin)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Get the address of the plugin author's home page.
   Returns NULL if author homepage is not present.
   Returned value must be freed by caller.
*/
    pub fn lilv_plugin_get_author_homepage(plugin: *const LilvPlugin)
     -> *mut LilvNode;
}
extern "C" {
    /**
   Return true iff `plugin` has been replaced by another plugin.

   The plugin will still be usable, but hosts should hide them from their
   user interfaces to prevent users from using deprecated plugins.
*/
    pub fn lilv_plugin_is_replaced(plugin: *const LilvPlugin) -> bool;
}
extern "C" {
    /**
   Write the Turtle description of `plugin` to `plugin_file`.

   This function is particularly useful for porting plugins in conjunction with
   an LV2 bridge such as NASPRO.
*/
    pub fn lilv_plugin_write_description(world: *mut LilvWorld,
                                         plugin: *const LilvPlugin,
                                         base_uri: *const LilvNode,
                                         plugin_file: *mut FILE);
}
extern "C" {
    /**
   Write a manifest entry for `plugin` to `manifest_file`.

   This function is intended for use with lilv_plugin_write_description() to
   write a complete description of a plugin to a bundle.
*/
    pub fn lilv_plugin_write_manifest_entry(world: *mut LilvWorld,
                                            plugin: *const LilvPlugin,
                                            base_uri: *const LilvNode,
                                            manifest_file: *mut FILE,
                                            plugin_file_path:
                                                *const ::std::os::raw::c_char);
}
extern "C" {
    /**
   Get the resources related to `plugin` with lv2:appliesTo.

   Some plugin-related resources are not linked directly to the plugin with
   rdfs:seeAlso and thus will not be automatically loaded along with the plugin
   data (usually for performance reasons).  All such resources of the given @c
   type related to `plugin` can be accessed with this function.

   If `type` is NULL, all such resources will be returned, regardless of type.

   To actually load the data for each returned resource, use
   lilv_world_load_resource().
*/
    pub fn lilv_plugin_get_related(plugin: *const LilvPlugin,
                                   type_: *const LilvNode) -> *mut LilvNodes;
}
extern "C" {
    /**
   Get the RDF node of `port`.

   Ports nodes may be may be URIs or blank nodes.

   @return A shared node which must not be modified or freed.
*/
    pub fn lilv_port_get_node(plugin: *const LilvPlugin,
                              port: *const LilvPort) -> *const LilvNode;
}
extern "C" {
    /**
   Port analog of lilv_plugin_get_value().
*/
    pub fn lilv_port_get_value(plugin: *const LilvPlugin,
                               port: *const LilvPort,
                               predicate: *const LilvNode) -> *mut LilvNodes;
}
extern "C" {
    /**
   Get a single property value of a port.

   This is equivalent to lilv_nodes_get_first(lilv_port_get_value(...)) but is
   simpler to use in the common case of only caring about one value.  The
   caller is responsible for freeing the returned node.
*/
    pub fn lilv_port_get(plugin: *const LilvPlugin, port: *const LilvPort,
                         predicate: *const LilvNode) -> *mut LilvNode;
}
extern "C" {
    /**
   Return the LV2 port properties of a port.
*/
    pub fn lilv_port_get_properties(plugin: *const LilvPlugin,
                                    port: *const LilvPort) -> *mut LilvNodes;
}
extern "C" {
    /**
   Return whether a port has a certain property.
*/
    pub fn lilv_port_has_property(p: *const LilvPlugin, port: *const LilvPort,
                                  property_uri: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Return whether a port supports a certain event type.

   More precisely, this returns true iff the port has an atom:supports or an
   ev:supportsEvent property with `event_type` as the value.
*/
    pub fn lilv_port_supports_event(p: *const LilvPlugin,
                                    port: *const LilvPort,
                                    event_type: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Get the index of a port.
   The index is only valid for the life of the plugin and may change between
   versions.  For a stable identifier, use the symbol.
*/
    pub fn lilv_port_get_index(plugin: *const LilvPlugin,
                               port: *const LilvPort) -> u32;
}
extern "C" {
    /**
   Get the symbol of a port.
   The 'symbol' is a short string, a valid C identifier.
   Returned value is owned by `port` and must not be freed.
*/
    pub fn lilv_port_get_symbol(plugin: *const LilvPlugin,
                                port: *const LilvPort) -> *const LilvNode;
}
extern "C" {
    /**
   Get the name of a port.
   This is guaranteed to return the untranslated name (the doap:name in the
   data file without a language tag).  Returned value must be freed by
   the caller.
*/
    pub fn lilv_port_get_name(plugin: *const LilvPlugin,
                              port: *const LilvPort) -> *mut LilvNode;
}
extern "C" {
    /**
   Get all the classes of a port.
   This can be used to determine if a port is an input, output, audio,
   control, midi, etc, etc, though it's simpler to use lilv_port_is_a().
   The returned list does not include lv2:Port, which is implied.
   Returned value is shared and must not be destroyed by caller.
*/
    pub fn lilv_port_get_classes(plugin: *const LilvPlugin,
                                 port: *const LilvPort) -> *const LilvNodes;
}
extern "C" {
    /**
   Determine if a port is of a given class (input, output, audio, etc).
   For convenience/performance/extensibility reasons, hosts are expected to
   create a LilvNode for each port class they "care about".  Well-known type
   URI strings are defined (e.g. LILV_URI_INPUT_PORT) for convenience, but
   this function is designed so that Lilv is usable with any port types
   without requiring explicit support in Lilv.
*/
    pub fn lilv_port_is_a(plugin: *const LilvPlugin, port: *const LilvPort,
                          port_class: *const LilvNode) -> bool;
}
extern "C" {
    /**
   Get the default, minimum, and maximum values of a port.

   `def`, `min`, and `max` are outputs, pass pointers to uninitialized
   LilvNode* variables.  These will be set to point at new values (which must
   be freed by the caller using lilv_node_free()), or NULL if the value does
   not exist.
*/
    pub fn lilv_port_get_range(plugin: *const LilvPlugin,
                               port: *const LilvPort,
                               deflt: *mut *mut LilvNode,
                               min: *mut *mut LilvNode,
                               max: *mut *mut LilvNode);
}
extern "C" {
    /**
   Get the scale points (enumeration values) of a port.
   This returns a collection of 'interesting' named values of a port
   (e.g. appropriate entries for a UI selector associated with this port).
   Returned value may be NULL if `port` has no scale points, otherwise it
   must be freed by caller with lilv_scale_points_free().
*/
    pub fn lilv_port_get_scale_points(plugin: *const LilvPlugin,
                                      port: *const LilvPort)
     -> *mut LilvScalePoints;
}
extern "C" {
    /**
   Load a state snapshot from the world RDF model.
   This function can be used to load the default state of a plugin by passing
   the plugin URI as the `subject` parameter.
   @param world The world.
   @param map URID mapper.
   @param subject The subject of the state description (e.g. a preset URI).
   @return A new LilvState which must be freed with lilv_state_free(), or NULL.
*/
    pub fn lilv_state_new_from_world(world: *mut LilvWorld,
                                     map: *mut LV2_URID_Map,
                                     subject: *const LilvNode)
     -> *mut LilvState;
}
extern "C" {
    /**
   Load a state snapshot from a file.
   @param world The world.
   @param map URID mapper.
   @param subject The subject of the state description (e.g. a preset URI).
   @param path The path of the file containing the state description.
   @return A new LilvState which must be freed with lilv_state_free().

   If `subject` is NULL, it is taken to be the URI of the file (i.e.
   "<>" in Turtle).

   This function parses the file separately to create the state, it does not
   parse the file into the world model, i.e. the returned state is the only
   new memory consumed once this function returns.
*/
    pub fn lilv_state_new_from_file(world: *mut LilvWorld,
                                    map: *mut LV2_URID_Map,
                                    subject: *const LilvNode,
                                    path: *const ::std::os::raw::c_char)
     -> *mut LilvState;
}
extern "C" {
    /**
   Load a state snapshot from a string made by lilv_state_to_string().
*/
    pub fn lilv_state_new_from_string(world: *mut LilvWorld,
                                      map: *mut LV2_URID_Map,
                                      str: *const ::std::os::raw::c_char)
     -> *mut LilvState;
}
/**
   Function to get a port value.
   @param port_symbol The symbol of the port.
   @param user_data The user_data passed to lilv_state_new_from_instance().
   @param size (Output) The size of the returned value.
   @param type (Output) The URID of the type of the returned value.
   @return A pointer to the port value.

   This function MUST set `size` and `type` appropriately.
*/
pub type LilvGetPortValueFunc =
    ::std::option::Option<unsafe extern "C" fn(port_symbol:
                                                   *const ::std::os::raw::c_char,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               size: *mut u32,
                                               type_: *mut u32)
                              -> *const ::std::os::raw::c_void>;
extern "C" {
    /**
   Create a new state snapshot from a plugin instance.

   @param plugin The plugin this state applies to.

   @param instance An instance of `plugin`.

   @param map The map to use for mapping URIs in state.

   @param file_dir Directory of files created by the plugin earlier (or NULL).
   This is for hosts that support file creation at any time with state
   state:makePath.  These files will be copied as necessary to `copy_dir` and
   not be referred to directly in state (a temporary directory is appropriate).

   @param copy_dir Directory of copies of files in `file_dir` (or NULL).  This
   directory will have the same structure as `file_dir` but with possibly
   modified file names to distinguish different revisions.  If you only care
   about saving one state snapshot, it can be the same as `save_dir`.  Plugin
   state will refer to files in this directory.

   @param save_dir Directory of files created by plugin during save (or NULL).
   If the state will be saved, this should be the bundle directory later passed
   to lilv_state_save().

   @param get_value Function to get port values (or NULL).  If NULL, the
   returned state will not represent port values.  This should only be NULL in
   hosts that save and restore port values via some other mechanism.

   @param user_data User data to pass to `get_value`.

   @param link_dir Directory of links to external files (or NULL).  A link will
   be made in this directory to any external files referred to in plugin state.
   In turn, links will be created in the save directory to these links (e.g.
   save_dir/file => link_dir/file => /foo/bar/file).  This allows many state
   snapshots to share a single link to an external file, so archival
   (e.g. with tar -h) will not create several copies of the file.  If this is
   not required, it can be the same as save_dir.

   @param flags Bitwise OR of LV2_State_Flags values.

   @param features Features to pass LV2_State_Interface.save().

   @return A new LilvState which must be freed with lilv_state_free().

   This function may be called simultaneously with any instance function
   (except discovery functions) unless the threading class of that function
   explicitly disallows this.

   To support advanced file functionality, there are several directory
   parameters.  Simple hosts that only wish to save a single plugins state once
   may simply use the same directory for all of them (or pass NULL to not
   support files at all).  The multiple parameters are necessary to support
   saving an instances state many times while avoiding any duplication of data.

   If supported (via state:makePath passed to LV2_Descriptor::instantiate()),
   `file_dir` should be the directory where any files created by the plugin
   (not during save time, e.g. during instantiation) are stored.  These files
   will be copied to preserve their state at this time.plugin-created files are stored.
   Lilv will assume any files within this directory (recursively) are created
   by the plugin and all other files are immutable.  Note that this function
   does not save the state, use lilv_state_save() for that.

   See <a href="http://lv2plug.in/ns/ext/state/state.h">state.h</a> from the
   LV2 State extension for details on the `flags` and `features` parameters.
*/
    pub fn lilv_state_new_from_instance(plugin: *const LilvPlugin,
                                        instance: *mut LilvInstance,
                                        map: *mut LV2_URID_Map,
                                        file_dir:
                                            *const ::std::os::raw::c_char,
                                        copy_dir:
                                            *const ::std::os::raw::c_char,
                                        link_dir:
                                            *const ::std::os::raw::c_char,
                                        save_dir:
                                            *const ::std::os::raw::c_char,
                                        get_value: LilvGetPortValueFunc,
                                        user_data:
                                            *mut ::std::os::raw::c_void,
                                        flags: u32,
                                        features: *const *const LV2_Feature)
     -> *mut LilvState;
}
extern "C" {
    /**
   Free `state`.
*/
    pub fn lilv_state_free(state: *mut LilvState);
}
extern "C" {
    /**
   Return true iff `a` is equivalent to `b`.
*/
    pub fn lilv_state_equals(a: *const LilvState, b: *const LilvState)
     -> bool;
}
extern "C" {
    /**
   Return the number of properties in `state`.
*/
    pub fn lilv_state_get_num_properties(state: *const LilvState)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
   Get the URI of the plugin `state` applies to.
*/
    pub fn lilv_state_get_plugin_uri(state: *const LilvState)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the URI of `state`.

   This may return NULL if the state has not been saved and has no URI.
*/
    pub fn lilv_state_get_uri(state: *const LilvState) -> *const LilvNode;
}
extern "C" {
    /**
   Get the label of `state`.
*/
    pub fn lilv_state_get_label(state: *const LilvState)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
   Set the label of `state`.
*/
    pub fn lilv_state_set_label(state: *mut LilvState,
                                label: *const ::std::os::raw::c_char);
}
extern "C" {
    /**
   Set a metadata property on `state`.
   @param state The state to set the metadata for.
   @param key The key to store `value` under (URID).
   @param value Pointer to the value to be stored.
   @param size The size of `value` in bytes.
   @param type The type of `value` (URID).
   @param flags LV2_State_Flags for `value`.
   @return 0 on success.

   This is a generic version of lilv_state_set_label(), which sets metadata
   properties visible to hosts, but not plugins.  This allows storing useful
   information such as comments or preset banks.
*/
    pub fn lilv_state_set_metadata(state: *mut LilvState, key: u32,
                                   value: *const ::std::os::raw::c_void,
                                   size: usize, type_: u32, flags: u32)
     -> ::std::os::raw::c_int;
}
/**
   Function to set a port value.
   @param port_symbol The symbol of the port.
   @param user_data The user_data passed to lilv_state_restore().
   @param size The size of `value`.
   @param type The URID of the type of `value`.
   @param value A pointer to the port value.
*/
pub type LilvSetPortValueFunc =
    ::std::option::Option<unsafe extern "C" fn(port_symbol:
                                                   *const ::std::os::raw::c_char,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               value:
                                                   *const ::std::os::raw::c_void,
                                               size: u32, type_: u32)>;
extern "C" {
    /**
   Enumerate the port values in a state snapshot.
   @param state The state to retrieve port values from.
   @param set_value A function to receive port values.
   @param user_data User data to pass to `set_value`.

   This function is a subset of lilv_state_restore() that only fires the
   `set_value` callback and does not directly affect a plugin instance.  This
   is useful in hosts that need to retrieve the port values in a state snapshot
   for special handling.
*/
    pub fn lilv_state_emit_port_values(state: *const LilvState,
                                       set_value: LilvSetPortValueFunc,
                                       user_data:
                                           *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
   Restore a plugin instance from a state snapshot.
   @param state The state to restore, which must apply to the correct plugin.
   @param instance An instance of the plugin `state` applies to, or NULL.
   @param set_value A function to set a port value (may be NULL).
   @param user_data User data to pass to `set_value`.
   @param flags Bitwise OR of LV2_State_Flags values.
   @param features Features to pass LV2_State_Interface.restore().

   This will set all the properties of `instance`, if given, to the values
   stored in `state`.  If `set_value` is provided, it will be called (with the
   given `user_data`) to restore each port value, otherwise the host must
   restore the port values itself (using lilv_state_get_port_value()) in order
   to completely restore `state`.

   If the state has properties and `instance` is given, this function is in
   the "instantiation" threading class, i.e. it MUST NOT be called
   simultaneously with any function on the same plugin instance.  If the state
   has no properties, only port values are set via `set_value`.

   See <a href="http://lv2plug.in/ns/ext/state/state.h">state.h</a> from the
   LV2 State extension for details on the `flags` and `features` parameters.
*/
    pub fn lilv_state_restore(state: *const LilvState,
                              instance: *mut LilvInstance,
                              set_value: LilvSetPortValueFunc,
                              user_data: *mut ::std::os::raw::c_void,
                              flags: u32,
                              features: *const *const LV2_Feature);
}
extern "C" {
    /**
   Save state to a file.
   @param world The world.
   @param map URID mapper.
   @param unmap URID unmapper.
   @param state State to save.
   @param uri URI of state, may be NULL.
   @param dir Path of the bundle directory to save into.
   @param filename Path of the state file relative to `dir`.

   The format of state on disk is compatible with that defined in the LV2
   preset extension, i.e. this function may be used to save presets which can
   be loaded by any host.

   If `uri` is NULL, the preset URI will be a file URI, but the bundle
   can safely be moved (i.e. the state file will use "<>" as the subject).
*/
    pub fn lilv_state_save(world: *mut LilvWorld, map: *mut LV2_URID_Map,
                           unmap: *mut LV2_URID_Unmap,
                           state: *const LilvState,
                           uri: *const ::std::os::raw::c_char,
                           dir: *const ::std::os::raw::c_char,
                           filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Save state to a string.  This function does not use the filesystem.

   @param world The world.
   @param map URID mapper.
   @param unmap URID unmapper.
   @param state The state to serialize.
   @param uri URI for the state description (mandatory).
   @param base_uri Base URI for serialisation.  Unless you know what you are
   doing, pass NULL for this, otherwise the state may not be restorable via
   lilv_state_new_from_string().
*/
    pub fn lilv_state_to_string(world: *mut LilvWorld, map: *mut LV2_URID_Map,
                                unmap: *mut LV2_URID_Unmap,
                                state: *const LilvState,
                                uri: *const ::std::os::raw::c_char,
                                base_uri: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /**
   Unload a state from the world and delete all associated files.
   @param world The world.
   @param state State to remove from the system.

   This function DELETES FILES/DIRECTORIES FROM THE FILESYSTEM!  It is intended
   for removing user-saved presets, but can delete any state the user has
   permission to delete, including presets shipped with plugins.

   The rdfs:seeAlso file for the state will be removed.  The entry in the
   bundle's manifest.ttl is removed, and if this results in an empty manifest,
   then the manifest file is removed.  If this results in an empty bundle, then
   the bundle directory is removed as well.
*/
    pub fn lilv_state_delete(world: *mut LilvWorld, state: *const LilvState)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
   Get the label of this scale point (enumeration value)
   Returned value is owned by `point` and must not be freed.
*/
    pub fn lilv_scale_point_get_label(point: *const LilvScalePoint)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the value of this scale point (enumeration value)
   Returned value is owned by `point` and must not be freed.
*/
    pub fn lilv_scale_point_get_value(point: *const LilvScalePoint)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the URI of this class' superclass.
   Returned value is owned by `plugin_class` and must not be freed by caller.
   Returned value may be NULL, if class has no parent.
*/
    pub fn lilv_plugin_class_get_parent_uri(plugin_class:
                                                *const LilvPluginClass)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the URI of this plugin class.
   Returned value is owned by `plugin_class` and must not be freed by caller.
*/
    pub fn lilv_plugin_class_get_uri(plugin_class: *const LilvPluginClass)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the label of this plugin class, ie "Oscillators".
   Returned value is owned by `plugin_class` and must not be freed by caller.
*/
    pub fn lilv_plugin_class_get_label(plugin_class: *const LilvPluginClass)
     -> *const LilvNode;
}
extern "C" {
    /**
   Get the subclasses of this plugin class.
   Returned value must be freed by caller with lilv_plugin_classes_free().
*/
    pub fn lilv_plugin_class_get_children(plugin_class:
                                              *const LilvPluginClass)
     -> *mut LilvPluginClasses;
}
extern "C" {
    /**
   Instantiate a plugin.
   The returned value is a lightweight handle for an LV2 plugin instance,
   it does not refer to `plugin`, or any other Lilv state.  The caller must
   eventually free it with lilv_instance_free().
   `features` is a NULL-terminated array of features the host supports.
   NULL may be passed if the host supports no additional features.
   @return NULL if instantiation failed.
*/
    pub fn lilv_plugin_instantiate(plugin: *const LilvPlugin,
                                   sample_rate: f64,
                                   features: *const *const LV2_Feature)
     -> *mut LilvInstance;
}
extern "C" {
    /**
   Free a plugin instance.
   It is safe to call this function on NULL.
   `instance` is invalid after this call.
*/
    pub fn lilv_instance_free(instance: *mut LilvInstance);
}
extern "C" {
    /**
   Get all UIs for `plugin`.
   Returned value must be freed by caller using lilv_uis_free().
*/
    pub fn lilv_plugin_get_uis(plugin: *const LilvPlugin) -> *mut LilvUIs;
}
extern "C" {
    /**
   Get the URI of a Plugin UI.
   @param ui The Plugin UI
   @return a shared value which must not be modified or freed.
*/
    pub fn lilv_ui_get_uri(ui: *const LilvUI) -> *const LilvNode;
}
extern "C" {
    /**
   Get the types (URIs of RDF classes) of a Plugin UI.
   @param ui The Plugin UI
   @return a shared value which must not be modified or freed.

   Note that in most cases lilv_ui_is_supported() should be used, which avoids
   the need to use this function (and type specific logic).
*/
    pub fn lilv_ui_get_classes(ui: *const LilvUI) -> *const LilvNodes;
}
extern "C" {
    /**
   Check whether a plugin UI has a given type.
   @param ui        The Plugin UI
   @param class_uri The URI of the LV2 UI type to check this UI against
*/
    pub fn lilv_ui_is_a(ui: *const LilvUI, class_uri: *const LilvNode)
     -> bool;
}
/**
   Function to determine whether a UI type is supported.

   This is provided by the user and must return non-zero iff using a UI of type
   `ui_type_uri` in a container of type `container_type_uri` is supported.
*/
pub type LilvUISupportedFunc =
    ::std::option::Option<unsafe extern "C" fn(container_type_uri:
                                                   *const ::std::os::raw::c_char,
                                               ui_type_uri:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_uint>;
extern "C" {
    /**
   Return true iff a Plugin UI is supported as a given widget type.
   @param ui The Plugin UI
   @param supported_func User provided supported predicate.
   @param container_type The widget type to host the UI within.
   @param ui_type (Output) If non-NULL, set to the native type of the UI
   which is owned by `ui` and must not be freed by the caller.
   @return The embedding quality level returned by `supported_func`.
*/
    pub fn lilv_ui_is_supported(ui: *const LilvUI,
                                supported_func: LilvUISupportedFunc,
                                container_type: *const LilvNode,
                                ui_type: *mut *const LilvNode)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
   Get the URI for a Plugin UI's bundle.
   @param ui The Plugin UI
   @return a shared value which must not be modified or freed.
*/
    pub fn lilv_ui_get_bundle_uri(ui: *const LilvUI) -> *const LilvNode;
}
extern "C" {
    /**
   Get the URI for a Plugin UI's shared library.
   @param ui The Plugin UI
   @return a shared value which must not be modified or freed.
*/
    pub fn lilv_ui_get_binary_uri(ui: *const LilvUI) -> *const LilvNode;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
